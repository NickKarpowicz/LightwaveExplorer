<?xml version="1.0" encoding="UTF-8"?>
<!-- Copyright 2023 Nicholas Karpowicz -->
<component type="desktop-application">
  <id>io.github.NickKarpowicz.LightwaveExplorer</id>
  
  <name>Lightwave Explorer</name>
  <summary>An efficient, user-friendly solver for nonlinear light-matter interaction</summary>
  <launchable type="desktop-id">io.github.NickKarpowicz.LightwaveExplorer.desktop</launchable>
  <metadata_license>CC0-1.0</metadata_license>
  <project_license>MIT</project_license>
  <content_rating type="oars-1.1" />
  <releases>
  <release version="2023.08.04" date="2023-08-15" urgency="high">
  <description>
  <p>This is the initial Flatpak release.</p>
  </description>
  </release>
  </releases>
  <url type="homepage">https://github.com/NickKarpowicz/LightwaveExplorer</url>
  <description>
    <p>
      Lightwave explorer is an open source nonlinear optics simulator, intended to be fast, visual, and flexible for students and researchers to play with ultrashort laser pulses and nonlinear optics without having to buy a laser first.
    </p>
    <p>
      The simulation was written CUDA in order to run quickly on graphics cards, but also supports CPU-based simulations. It has successfully been applied to several recent studies (see a list of publications on the Github page), and will continually gain new features and a larger material database as the community of users grows. It is open source (essential for reproducible scientific work) and multiplatform. Its purpose and goals are:
    </p>
    <ul>
      <li>Easily extensible database of materials: Eveything the program knows about nonlinear materials comes from a human-readable text file giving the appropriate coefficients and tensors. If you want to use a new material, or you've done a measurement in a new range where typical extrapolations from older data isn't relevant, it's easy to add and correct. There are places for references for the key parameters, and these references are stored in the saved simulation results for future reference. Especially if you have simulations that you checked against experiments, I'd be very happy for you to add your crystal definitions to the central database in the project Github.</li>
      <li>Accurate modeling of nonlinear optics using multiple, user-selectable physical models, including the unidirectional nonlinear wave equation and finite-difference time-domain approaches. This allows calculations that accommodate large systems where forward-propagation is an appropriate assumption, but also of etalon effects in thin crystals where reflections cannot be neglected.</li>
      <li>Efficient code so that complicated systems can be simulated in 3D: Real laser pulses can be messy, and if they weren't so before a nonlinear crystal, there's a good chance they are after (but not always). If things are slow, it's hard to go beyond one dimension on tolerable time scales, and then you miss out on the whole weird world of spatiotemporal couplings. Here you have options for rather fast simulations when there's a symmetry to apply (e.g. cylindrical or along one Cartesian dimension), alongside fully 3D propagation. Runs natively on both GPU and CPU to make use of whatever you have to work with.</li>
      <li>A graphical interface that lets you see what you're doing: A lot of us think in visual terms. Being able to adjust and scan parameters and immediately see what happens can really make it easier to understand what you're looking at. </li>
      <li>A flexible sequence mode: By stringing together elements, not just nonlinear crystals but also spherical or parabolic mirrors, apertures, filters, free space propagation and other elements, simulate how  one interaction affects another. Sequences of events can be scripted and even programmed with loop functions to see how things change over the course of repeated interactions.</li>
      <li>Fitting modes: Sometimes the data that we measure depends in an interesting way on a parameter, and we'd actually like to go back and figure out what that parameter was from the data. Solving this kind of inverse problem can be tough when the parameter lives inside a partial differential equation, but by simulating the whole thing and doing a fit, you have a chance to do it! The fitting algorithm can be used to narrow down a huge space of variables to come at your best estimation of what was happening in an experiment, or to adjust your experimental system to maximize output at a given frequency.</li>
      <li>A Python module for easy postprocessing of the results</li>
    </ul>
  </description>
  
  <launchable type="desktop-id">io.github.NickKarpowicz.LightwaveExplorer.desktop</launchable>
  <screenshots>
    <screenshot type="default">
      <image>https://raw.githubusercontent.com/NickKarpowicz/LightwaveExplorer/master/Documentation/Images/flatpakScreenshot.png</image>
    </screenshot>
  </screenshots>
</component>